


// // 1.	создать 3 инпута для ввода какого-то текста
// // 2.	напишите код JS, который найдёт эти 3 элемента и запишет в 
// них ваше имя (в каждый элемент ВАШЕ ИМЯ, то есть одинаковое значение, например “Дима”, “Дима”, “Дима”)
// // 3.	ниже напишите код JS, который найдёт эти 3 элемента и 
// запишет в них вашу ФАМИЛИЮ (в каждый элемент ВАШУ ФАМИЛИЮ, то есть одинаковое значение)
// // 4.	Как результат выполнения всей программы мы увидим в 3-х инпутах вашу фамилию
// // 5.	А потом возьмите и опять вставьте кусок кода из пункта 2
//  ниже куска из пункта 3. То есть мы сначала во все инпуты записали ИМЯ, потом ФАМИЛИЮ, 
//  а потом опять ИМЯ. Вот кусок кода с записью ИМЕНИ мы,получается, дублируем. Грех номер 1.   
// // 6.	оберните код из пункта 2 в фунцию с именем: setMyNameToAllInputs.
// // 7.	В итоге замените везде вызов кода из пункта 2 на вызов функции setMyNameToAllInputs.
// // 8.	Давайте теперь ИНКАПСУЛИРУЕМ логику из пункта 3 так же в ф-цию с 
// именем setMyLastNameToAllInputs, которая найдет эти инпуты и запишет в них вашу фамилию
// // 9.	вызвать эту ф-цию setMyLastNameToAllInputs();
// // 10.	Кода стало меньше. Мы можем теперь эти вызовы функций вставлять 
// куда захотим и переиспользовать код многократно
// // 11.	Но мы видим, что 2 функции очень похожи. По сути тот же главный грех - ДУБЛИРОВАНИЕ КОДА!!!
// // 12.	Задача - из двух очень похожих функций выделить третью. Для этого небольшая подготовка
// // 13.	сделать эти 2 функции МАКСИМАЛЬНо похожими друг на друга:
// // - избавляемся от дублирования внутри самих функций. Скорее всего у вас написано три раза что-то типа:
 
// blabla.value = "Dima";
// blabla2.value = "Dima";
// blabla3.value = "Dima";

// Дублируется здесь строковое значение "Dima".
// Выносим это значение в переменную:
 
// var newValue = "Dima";
// blabla.value = newValue;
// blabla2.value = newValue;
// blabla3.value = newValue;

// Аналогично делаем со второй функцией
 
// 14.	понять, чем эти ф-ции отличаются (подсказка: значением одной внутренней переменной) что-то типа:
 
// function setMyNameToAllInputs() {
//     var newValue = 'Dima';
//     // blabla меняем здесь значения
// }

// function setMyLastNameToAllInputs() {
//       var newValue = 'Kuzyuberdin';
//     // blabla меняем здесь значения
// } 
// 15.	написать 3-ю ф-цию changeValue, которая будет универсальной и в качестве параметра принимать то, чем отличаются ф-ции 1 и 2:

 
// function changeValue(newValue) {
//             // то есть уже нет здесь объявления переменной.
//             // эта переменная стала параметром, значение которого придёт             
//извне, когда функцию вызовут

//         // blabla меняем здесь значения
// }
 


 
// 16.	закомментируйте отовсюду функции setMyLastNameToAllInputs  и setMyLastNameToAllInputs и заюзайте новую универсальную функцию с параметром вместо неё, получится что-то типа:
// changeValue("it-kamasutra");
// changeValue("google");
// changeValue("it-kamasutra");
 
// 17.	добавьте в css класс error (border: red 1px solid)
// 18.	Напишите простой линейный строчка за строчкой код, который найдёт все 3 инпута с помощью getElementById (обязательно так) и каждому элементу добавим класс error (то же что и во втором пункте, только не меняем значение value, а добавляем класс error)
// 19.	Видим дублирование кода. Хотим сократить дублирование.
// 20.	напишите функцию setError, которая будет принимать параметром id элемента. внутри себя эта функция будет находить элемент по этому айди и устанавливать класс error для этого элемента.
// 21.	применим вместо кода из пункта 18 нашу функцию. Кода стало меньше! Круто! Красавчики!
// 22.	добавьте в разметку отдельных два элемента, не вложенных друг в друга: div и textarea (заполните любым контентом их).
// Вызовите ф-цию setError дважды: один раз с id дивки, другой раз - с id textarea.
// setError("div-id");
// setError("textarea-id");

// Результат: видим бордер у обоих элементов
// 23.	То есть у нас есть универсальная функция и мы можем ею пользоваться где захотим.
    
// 24.	написать ф-кцию getSumm, которая будет возвращать сумму двух чисел, переданных как параметры. (с помощью return)
// 25.	посчитайте несколько сумм getSumm(34,23); getSumm(3434,12); getSumm(23,23);

// возвращённые значения нужно вывести в консоль:

 
// var result1 = getSumm(23,34);
// console.log(result1);

 
// 26.	создайте ф-цию sayHello, которая внутри себя вызовет alert(‘My name’)
// 27.	setTimeout выполняет какую-то функцию с задержкой по времени. пример кода:
// setTimeout(sayHello, 1000); где 1000 - миллисекунды, через которые будет выполнена ф-ция sayHello.
// Внимательно на код гляньте ниже, мы не ставим скобки после имени функции:
 
// setTimeout(sayHello, 1000);

// то есть мы отдаём функцию внутрь другой функции setTimeout. Скобки поставятся через секунду сами по себе (ну, window.setTimeout сделает это за нас)
 
// 28.	попробуйте вызвать ф-цию setError через setTimeout. Не получится легко, потому что setError ожидает параметр, а как параметр передаётся? в скобки засовывается. Но мы скобки не ставим. Их поставит через секунду кто-то за нас.
 
// В этом случае нам нужно создать функцию-обёртку timeoutError, которой не нужен id-шник. Внутри этой функции вызвать наш setError с нужным нам захардкодженым значением для параметра id.
// и внутрь setTimeout передать нашу обёртку (у обёртки параметров ведь нет, значит всё круто)
 
// 29.	4 способа, как спрятать элемент:
// 1.	display: none;
// 2.	visibility: hidden;
// 3.	width: 0px (или height:0 ) (хитрожопый способ)
// 4.	left (или top) -1000000000px (ещё более хитрожопый способ)
// 5.	есть ещё способ, погугли!
 

// написать ф-цию hideElement, которая будет прятать элемент по переданному этой функции в качестве параметра айдишнику
// 30.	написать ф-цию showElement, которая будет делать противоположное от предыдущего пункта
// 31.	setInterval работает как setTimeout, но он отрабатывает не один раз, а фигачит через заданный интервал пока не сдохнет браузер
// 32.	сделайте счётчик от 0 до бесконечности каждую секунду с помощью setInterval (секунды выводите в какой-нибудь инпут)
// 33.	в метод, который у вас находит сумму, передайте вместо нормальных двух чисел getSum(12, 34) числа-строки:
// getSum('12', '34');
// Те же числа, но взятые в кавычки. ПРограмма работать будет некорректно. Нужно это исправить)

